# JVM内存模型与垃圾回收

## 1. JVM内存结构

JVM在Java程序运行时把它所管理的内存划分为几个不同的数据区域：

### 1.1 程序计数器(Program Counter Register)

- **作用**：记录当前线程执行的字节码指令地址
- **特点**：
  - 线程私有，每个线程都有独立的程序计数器
  - 如果执行的是Java方法，计数器记录的是虚拟机字节码指令的地址
  - 如果执行的是Native方法，计数器值为空(Undefined)
  - 唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域

### 1.2 虚拟机栈(VM Stack)

- **作用**：存储局部变量表、操作数栈、动态链接、方法出口等信息
- **特点**：
  - 线程私有，生命周期与线程相同
  - 每个方法执行时都会创建一个栈帧(Stack Frame)
  - 栈帧包含：局部变量表、操作数栈、动态链接、方法返回地址
- **异常**：
  - StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度
  - OutOfMemoryError：虚拟机栈可以动态扩展，扩展时无法申请到足够的内存

### 1.3 本地方法栈(Native Method Stack)

- **作用**：为Native方法服务
- **特点**：与虚拟机栈类似，区别是虚拟机栈为Java方法服务，本地方法栈为Native方法服务

### 1.4 堆(Heap)

- **作用**：存放对象实例和数组
- **特点**：
  - 线程共享，是JVM管理的内存中最大的一块
  - 在虚拟机启动时创建
  - 是垃圾收集器管理的主要区域，因此也被称为"GC堆"
- **分区**：
  - **新生代(Young Generation)**：
    - Eden区：新对象首先分配在这里
    - Survivor区：分为S0和S1，用于存放经过Minor GC后存活的对象
  - **老年代(Old Generation)**：存放经过多次GC后仍然存活的对象
- **异常**：OutOfMemoryError: Java heap space

### 1.5 方法区(Method Area)

- **作用**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等
- **特点**：
  - 线程共享
  - JDK 8之前使用永久代(PermGen)实现
  - JDK 8及之后使用元空间(Metaspace)实现，使用本地内存
- **异常**：
  - JDK 6及之前：OutOfMemoryError: PermGen space
  - JDK 8及之后：OutOfMemoryError: Metaspace

### 1.6 运行时常量池(Runtime Constant Pool)

- **作用**：存放编译期生成的各种字面量和符号引用
- **特点**：是方法区的一部分

## 2. 对象创建过程

虚拟机遇到一条new指令时：

1. **检查类是否已加载**：检查引用代表的类是否被加载过、解析和初始化过
2. **分配内存**：在类加载通过之后，虚拟机将为新生对象分配内存
   - **指针碰撞**：如果堆内存是规整的，使用指针碰撞方式分配
   - **空闲列表**：如果堆内存不规整，使用空闲列表方式分配
3. **初始化零值**：虚拟机将分配到的内存空间都初始化为零值(不包括对象头)
4. **设置对象头**：对对象进行一系列设置，例如：对象是哪个类的实例、对象的哈希码、GC分代年龄等
5. **执行init方法**：执行完new指令之后会接着执行`<init>`方法，把对象按照程序员的意愿初始化

## 3. 垃圾回收

### 3.1 判断对象是否可回收

#### 3.1.1 引用计数算法

- **原理**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1
- **缺点**：无法解决循环引用的问题

#### 3.1.2 可达性分析算法

- **原理**：通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
- **GC Roots对象包括**：
  - 虚拟机栈中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI引用的对象

### 3.2 引用类型

- **强引用(Strong Reference)**：类似`Object obj = new Object()`，只要强引用存在，垃圾收集器永远不会回收被引用的对象
- **软引用(Soft Reference)**：在内存不足时会被回收
- **弱引用(Weak Reference)**：在垃圾回收时会被回收
- **虚引用(Phantom Reference)**：无法通过虚引用获取对象实例，主要用于跟踪对象被垃圾回收的活动

### 3.3 垃圾回收算法

#### 3.3.1 标记-清除算法(Mark-Sweep)

- **过程**：
  1. 标记：标记所有需要回收的对象
  2. 清除：清除被标记的对象
- **缺点**：
  - 效率问题：标记和清除两个过程的效率都不高
  - 空间问题：标记清除后会产生大量不连续的内存碎片

#### 3.3.2 复制算法(Copying)

- **过程**：将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉
- **优点**：实现简单，运行高效，没有内存碎片
- **缺点**：内存利用率低，只有50%
- **应用**：新生代的Eden区和Survivor区

#### 3.3.3 标记-整理算法(Mark-Compact)

- **过程**：
  1. 标记：标记所有需要回收的对象
  2. 整理：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
- **优点**：没有内存碎片，内存利用率高
- **缺点**：需要移动对象，效率较低
- **应用**：老年代

#### 3.3.4 分代收集算法(Generational Collection)

- **原理**：根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代
- **新生代**：采用复制算法
- **老年代**：采用标记-清除或标记-整理算法

### 3.4 GC类型

- **Minor GC / Young GC**：新生代(Eden、S0、S1)进行回收
- **Major GC / Old GC**：老年代进行回收
- **Mixed GC**：收集整个新生代以及部分老年代的垃圾收集
- **Full GC**：收集整个Java堆和方法区的垃圾收集

### 3.5 Stop The World (STW)

- **含义**：在垃圾回收过程中，除了垃圾回收线程，其他所有线程都会被暂停
- **影响**：会导致应用程序暂停，影响用户体验
- **优化**：通过并发收集、增量收集等方式减少STW时间

## 4. 垃圾收集器

### 4.1 Serial收集器

- **特点**：单线程收集器，进行垃圾收集时必须暂停其他所有工作线程
- **应用场景**：Client模式下的默认新生代收集器

### 4.2 ParNew收集器

- **特点**：Serial收集器的多线程版本
- **应用场景**：Server模式下的首选新生代收集器

### 4.3 Parallel Scavenge收集器

- **特点**：新生代收集器，使用复制算法，并行多线程收集
- **目标**：达到可控制的吞吐量

### 4.4 Serial Old收集器

- **特点**：Serial收集器的老年代版本，单线程收集器，使用标记-整理算法

### 4.5 Parallel Old收集器

- **特点**：Parallel Scavenge收集器的老年代版本，多线程收集器，使用标记-整理算法

### 4.6 CMS收集器(Concurrent Mark Sweep)

- **特点**：以获取最短回收停顿时间为目标的收集器
- **过程**：
  1. 初始标记：标记GC Roots能直接关联到的对象
  2. 并发标记：进行GC Roots Tracing
  3. 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
  4. 并发清除：清除标记的对象
- **优点**：并发收集，低停顿
- **缺点**：对CPU资源敏感，无法处理浮动垃圾，产生大量空间碎片

### 4.7 G1收集器(Garbage First)

- **特点**：面向服务端应用的垃圾收集器
- **优势**：
  - 并行与并发
  - 分代收集
  - 空间整合：整体采用标记-整理算法，局部采用复制算法
  - 可预测的停顿：可以建立可预测的停顿时间模型

## 5. JVM调优参数

### 5.1 堆内存参数

```bash
# 设置初始堆大小
-Xms512m

# 设置最大堆大小
-Xmx1024m

# 设置新生代大小
-Xmn256m

# 设置老年代与新生代的比例
-XX:NewRatio=2

# 设置Eden区与Survivor区的比例
-XX:SurvivorRatio=8
```

### 5.2 方法区参数

```bash
# JDK 8之前：永久代大小
-XX:PermSize=128m
-XX:MaxPermSize=256m

# JDK 8及之后：元空间大小
-XX:MetaspaceSize=128m
-XX:MaxMetaspaceSize=256m
```

### 5.3 栈参数

```bash
# 设置栈大小
-Xss1m
```

### 5.4 GC参数

```bash
# 输出详细的GC处理日志
-XX:+PrintGCDetails

# 输出GC时间戳
-XX:+PrintGCDateStamps

# 输出GC日志到文件
-Xloggc:gc.log

# 使用G1收集器
-XX:+UseG1GC

# 设置G1最大停顿时间
-XX:MaxGCPauseMillis=200
```

## 6. 常见内存溢出

### 6.1 堆溢出

- **错误**：`java.lang.OutOfMemoryError: Java heap space`
- **原因**：对象过多，堆内存不足
- **解决**：增加堆内存大小(-Xmx)，检查是否有内存泄漏

### 6.2 栈溢出

- **错误**：`java.lang.StackOverflowError`
- **原因**：方法调用层次过深，栈深度超过限制
- **解决**：增加栈大小(-Xss)，检查是否有无限递归

### 6.3 方法区溢出

- **JDK 6及之前**：`java.lang.OutOfMemoryError: PermGen space`
- **JDK 8及之后**：`java.lang.OutOfMemoryError: Metaspace`
- **原因**：加载的类过多，常量池过大
- **解决**：增加方法区大小，检查是否有类加载器泄漏

## 7. JVM调优工具

### 7.1 jconsole

- **功能**：Java监控和管理控制台
- **用途**：监控内存、线程、类加载等情况

### 7.2 jvisualvm

- **功能**：jconsole的升级版，功能更强大
- **用途**：性能分析、内存分析、线程分析

### 7.3 jstack

- **功能**：生成线程快照
- **用途**：定位线程死锁、线程阻塞等问题

### 7.4 jmap

- **功能**：生成堆转储快照
- **用途**：分析内存泄漏、对象分布

### 7.5 jstat

- **功能**：监控JVM统计信息
- **用途**：监控GC情况、类加载情况

## 8. 类加载机制

### 8.1 类加载过程

1. **加载(Loading)**：通过类的全限定名获取类的二进制字节流，将字节流转换为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象
2. **验证(Verification)**：确保Class文件的字节流中包含的信息符合当前虚拟机的要求
3. **准备(Preparation)**：为类变量分配内存并设置初始值
4. **解析(Resolution)**：将常量池中的符号引用替换为直接引用
5. **初始化(Initialization)**：执行类构造器`<clinit>()`方法

### 8.2 类加载器

#### 8.2.1 启动类加载器(Bootstrap ClassLoader)

- **作用**：加载JAVA中的一些核心类库，主要是位于`<JAVA_HOME>/lib/rt.jar`中
- **特点**：由C++编写，无法通过程序得到

#### 8.2.2 扩展类加载器(Extension ClassLoader)

- **作用**：主要加载JAVA中的一些扩展类，位于`<JAVA_HOME>/lib/ext`中
- **特点**：是启动类加载器的子类

#### 8.2.3 应用类加载器(Application ClassLoader / System ClassLoader)

- **作用**：主要用于加载CLASSPATH路径下我们自己写的类
- **特点**：是扩展类加载器的子类

### 8.3 双亲委派模型

- **原理**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载
- **优点**：
  - 避免类的重复加载
  - 保证Java核心API的类型安全

## 9. 性能调优建议

1. **合理设置堆内存大小**：根据应用实际情况设置-Xms和-Xmx
2. **选择合适的垃圾收集器**：根据应用特点选择Serial、Parallel、CMS、G1等
3. **监控GC情况**：定期查看GC日志，分析GC频率和耗时
4. **避免内存泄漏**：及时释放不再使用的对象引用
5. **优化代码**：减少对象创建，使用对象池等
6. **使用性能分析工具**：定期使用jvisualvm等工具分析性能瓶颈

