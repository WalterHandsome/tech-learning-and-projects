# 缓存策略

> Python 应用缓存优化策略

## 1. 内存缓存

### 1.1 functools.lru_cache

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def expensive_function(n):
    # 耗时计算
    return sum(i**2 for i in range(n))

# 第一次调用会计算
result1 = expensive_function(1000)

# 第二次调用从缓存获取
result2 = expensive_function(1000)  # 快速返回
```

### 1.2 cachetools

```python
from cachetools import TTLCache, LRUCache

# TTL缓存（时间过期）
cache = TTLCache(maxsize=100, ttl=3600)

# LRU缓存（最近最少使用）
cache = LRUCache(maxsize=100)

def get_user(user_id):
    if user_id in cache:
        return cache[user_id]
    
    user = fetch_user_from_db(user_id)
    cache[user_id] = user
    return user
```

## 2. Redis 缓存

### 2.1 基础使用

```python
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def get_user_cached(user_id):
    cache_key = f"user:{user_id}"
    
    # 从缓存获取
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)
    
    # 从数据库获取
    user = fetch_user_from_db(user_id)
    
    # 写入缓存
    redis_client.setex(
        cache_key,
        3600,  # TTL: 1小时
        json.dumps(user.to_dict())
    )
    
    return user
```

### 2.2 缓存模式

```python
# Cache-Aside模式
def get_data(key):
    # 1. 先查缓存
    data = redis_client.get(key)
    if data:
        return json.loads(data)
    
    # 2. 查数据库
    data = fetch_from_db(key)
    
    # 3. 写入缓存
    redis_client.setex(key, 3600, json.dumps(data))
    return data

# Write-Through模式
def update_data(key, value):
    # 1. 更新数据库
    update_db(key, value)
    
    # 2. 更新缓存
    redis_client.setex(key, 3600, json.dumps(value))

# Write-Behind模式
def update_data_async(key, value):
    # 1. 更新缓存
    redis_client.setex(key, 3600, json.dumps(value))
    
    # 2. 异步更新数据库
    async_update_db(key, value)
```

## 3. 缓存失效

### 3.1 主动失效

```python
def invalidate_user_cache(user_id):
    cache_key = f"user:{user_id}"
    redis_client.delete(cache_key)

def update_user(user_id, data):
    # 更新数据库
    update_db(user_id, data)
    
    # 失效缓存
    invalidate_user_cache(user_id)
```

### 3.2 缓存预热

```python
def warmup_cache():
    # 预加载热门数据
    hot_users = get_hot_users()
    for user in hot_users:
        cache_key = f"user:{user.id}"
        redis_client.setex(
            cache_key,
            3600,
            json.dumps(user.to_dict())
        )
```

## 4. 分布式缓存

### 4.1 一致性哈希

```python
import hashlib

class ConsistentHash:
    def __init__(self, nodes):
        self.nodes = nodes
        self.ring = {}
        for node in nodes:
            for i in range(100):  # 虚拟节点
                key = f"{node}:{i}"
                hash_key = int(hashlib.md5(key.encode()).hexdigest(), 16)
                self.ring[hash_key] = node
    
    def get_node(self, key):
        hash_key = int(hashlib.md5(key.encode()).hexdigest(), 16)
        sorted_keys = sorted(self.ring.keys())
        for ring_key in sorted_keys:
            if hash_key <= ring_key:
                return self.ring[ring_key]
        return self.ring[sorted_keys[0]]

# 使用
hash_ring = ConsistentHash(['redis1', 'redis2', 'redis3'])
node = hash_ring.get_node('user:123')
```

## 5. 缓存穿透防护

### 5.1 布隆过滤器

```python
from pybloom_live import BloomFilter

# 创建布隆过滤器
bloom = BloomFilter(capacity=10000, error_rate=0.001)

# 添加存在的key
for user_id in existing_user_ids:
    bloom.add(f"user:{user_id}")

def get_user_safe(user_id):
    key = f"user:{user_id}"
    
    # 检查布隆过滤器
    if key not in bloom:
        return None  # 不存在，直接返回
    
    # 查缓存
    cached = redis_client.get(key)
    if cached:
        return json.loads(cached)
    
    # 查数据库
    user = fetch_user_from_db(user_id)
    if user:
        redis_client.setex(key, 3600, json.dumps(user.to_dict()))
        bloom.add(key)
    
    return user
```

## 6. 缓存雪崩防护

### 6.1 随机TTL

```python
import random

def set_cache_with_random_ttl(key, value, base_ttl=3600):
    # 随机TTL，避免同时过期
    ttl = base_ttl + random.randint(-300, 300)
    redis_client.setex(key, ttl, json.dumps(value))
```

### 6.2 多级缓存

```python
# L1: 本地缓存
local_cache = {}

# L2: Redis缓存
redis_client = redis.Redis()

def get_user_multi_level(user_id):
    key = f"user:{user_id}"
    
    # L1缓存
    if key in local_cache:
        return local_cache[key]
    
    # L2缓存
    cached = redis_client.get(key)
    if cached:
        user = json.loads(cached)
        local_cache[key] = user
        return user
    
    # 数据库
    user = fetch_user_from_db(user_id)
    if user:
        redis_client.setex(key, 3600, json.dumps(user.to_dict()))
        local_cache[key] = user
    
    return user
```

## 7. 总结

缓存策略要点：
- **内存缓存**：lru_cache、cachetools
- **Redis缓存**：基础使用、缓存模式（Cache-Aside、Write-Through、Write-Behind）
- **缓存失效**：主动失效、缓存预热
- **分布式缓存**：一致性哈希
- **缓存穿透防护**：布隆过滤器
- **缓存雪崩防护**：随机TTL、多级缓存

合理的缓存策略大幅提升应用性能。

