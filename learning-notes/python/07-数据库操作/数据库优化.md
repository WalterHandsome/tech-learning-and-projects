# 数据库优化

> Python 数据库性能优化和查询优化

## 1. 索引优化

### 1.1 创建索引

```python
from sqlalchemy import Index

# 单列索引
Index('idx_username', User.username)

# 复合索引
Index('idx_user_email', User.username, User.email)

# 唯一索引
Index('idx_unique_email', User.email, unique=True)
```

### 1.2 索引使用

```python
# 查询优化
session.query(User).filter(User.username == 'test').all()

# 使用索引的查询
session.query(User).filter(
    User.username == 'test',
    User.email == 'test@example.com'
).all()
```

## 2. 查询优化

### 2.1 避免N+1查询

```python
# 错误：N+1查询
users = session.query(User).all()
for user in users:
    print(user.posts)  # 每次循环都查询数据库

# 正确：预加载
from sqlalchemy.orm import joinedload

users = session.query(User).options(
    joinedload(User.posts)
).all()
```

### 2.2 批量操作

```python
# 批量插入
users = [User(username=f'user{i}') for i in range(1000)]
session.bulk_save_objects(users)
session.commit()

# 批量更新
session.query(User).filter(
    User.id.in_([1, 2, 3])
).update({'status': 'active'}, synchronize_session=False)
session.commit()
```

## 3. 连接池优化

### 3.1 连接池配置

```python
from sqlalchemy import create_engine

engine = create_engine(
    'postgresql://user:pass@localhost/db',
    pool_size=10,  # 连接池大小
    max_overflow=20,  # 最大溢出连接
    pool_pre_ping=True,  # 连接前ping
    pool_recycle=3600  # 连接回收时间
)
```

### 3.2 连接池监控

```python
from sqlalchemy import event
from sqlalchemy.pool import Pool

@event.listens_for(Pool, "connect")
def receive_connect(dbapi_conn, connection_record):
    print("新连接建立")

@event.listens_for(Pool, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    print("连接被检出")
```

## 4. 查询缓存

### 4.1 结果缓存

```python
from functools import lru_cache
from sqlalchemy.orm import Session

@lru_cache(maxsize=100)
def get_user_cached(session: Session, user_id: int):
    return session.query(User).filter(User.id == user_id).first()
```

### 4.2 Redis 缓存

```python
import redis
import json
from sqlalchemy.orm import Session

redis_client = redis.Redis(host='localhost', port=6379)

def get_user_with_cache(session: Session, user_id: int):
    cache_key = f"user:{user_id}"
    cached = redis_client.get(cache_key)
    
    if cached:
        return json.loads(cached)
    
    user = session.query(User).filter(User.id == user_id).first()
    if user:
        redis_client.setex(
            cache_key, 
            3600, 
            json.dumps(user.to_dict())
        )
    return user
```

## 5. 分页优化

### 5.1 游标分页

```python
# 偏移分页（慢）
users = session.query(User).offset(1000).limit(20).all()

# 游标分页（快）
last_id = 1000
users = session.query(User).filter(
    User.id > last_id
).order_by(User.id).limit(20).all()
```

## 6. 数据库分区

### 6.1 表分区

```python
from sqlalchemy import Table, Column, Integer, String

# 按月分区
partitions = []
for month in range(1, 13):
    partition = Table(
        f'logs_{month:02d}',
        metadata,
        Column('id', Integer),
        Column('message', String),
        # 分区配置
    )
    partitions.append(partition)
```

## 7. 总结

数据库优化要点：
- **索引优化**：单列索引、复合索引、唯一索引
- **查询优化**：避免N+1、预加载、批量操作
- **连接池优化**：连接池配置、连接监控
- **查询缓存**：结果缓存、Redis缓存
- **分页优化**：游标分页、偏移分页
- **数据库分区**：表分区、数据分布

数据库优化提高应用性能。

