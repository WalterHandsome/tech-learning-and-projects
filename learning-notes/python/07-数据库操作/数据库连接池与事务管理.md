# 数据库连接池与事务管理

> 高效管理数据库连接和处理事务

## 1. 连接池概述

连接池的优势：
- 复用连接，减少开销
- 控制并发连接数
- 提高性能
- 资源管理

## 2. SQLAlchemy 连接池

### 2.1 配置连接池

```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    'mysql+pymysql://user:password@localhost/dbname',
    poolclass=QueuePool,
    pool_size=10,           # 连接池大小
    max_overflow=20,        # 最大溢出连接
    pool_timeout=30,        # 获取连接超时
    pool_recycle=3600,      # 连接回收时间（秒）
    pool_pre_ping=True      # 连接前ping测试
)
```

### 2.2 连接池类型

```python
# QueuePool（默认）
from sqlalchemy.pool import QueuePool
engine = create_engine(url, poolclass=QueuePool)

# NullPool（无连接池）
from sqlalchemy.pool import NullPool
engine = create_engine(url, poolclass=NullPool)

# StaticPool（固定连接）
from sqlalchemy.pool import StaticPool
engine = create_engine(url, poolclass=StaticPool)
```

### 2.3 连接池监控

```python
# 获取连接池状态
pool = engine.pool
print(f"连接池大小: {pool.size()}")
print(f"已使用连接: {pool.checkedout()}")
print(f"溢出连接: {pool.overflow()}")
```

## 3. 会话管理

### 3.1 会话工厂

```python
from sqlalchemy.orm import sessionmaker

SessionLocal = sessionmaker(
    bind=engine,
    autocommit=False,
    autoflush=False,
    expire_on_commit=False
)

# 使用会话
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 3.2 会话作用域

```python
# 请求作用域（FastAPI）
from fastapi import Depends

@app.get("/users/")
async def get_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users

# 上下文管理器
with SessionLocal() as session:
    users = session.query(User).all()
```

## 4. 事务管理

### 4.1 基本事务

```python
from sqlalchemy.orm import Session

def create_user(db: Session, username: str, email: str):
    try:
        user = User(username=username, email=email)
        db.add(user)
        db.commit()
        db.refresh(user)
        return user
    except Exception as e:
        db.rollback()
        raise e
```

### 4.2 嵌套事务

```python
from sqlalchemy.orm import Session

def transfer_money(db: Session, from_id: int, to_id: int, amount: float):
    try:
        # 开始事务
        from_account = db.query(Account).filter_by(id=from_id).first()
        to_account = db.query(Account).filter_by(id=to_id).first()
        
        # 扣款
        from_account.balance -= amount
        if from_account.balance < 0:
            raise ValueError("余额不足")
        
        # 存款
        to_account.balance += amount
        
        # 提交事务
        db.commit()
    except Exception as e:
        db.rollback()
        raise e
```

### 4.3 保存点

```python
def complex_operation(db: Session):
    try:
        # 操作1
        user = User(username="alice")
        db.add(user)
        db.flush()  # 获取ID但不提交
        
        # 创建保存点
        savepoint = db.begin_nested()
        try:
            # 操作2（可能失败）
            profile = Profile(user_id=user.id, bio="...")
            db.add(profile)
            savepoint.commit()
        except:
            savepoint.rollback()
            # 回滚到保存点，但user仍然存在
        
        db.commit()
    except:
        db.rollback()
```

## 5. 事务装饰器

### 5.1 自定义装饰器

```python
from functools import wraps
from sqlalchemy.orm import Session

def transactional(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        db = kwargs.get('db') or args[0] if args else None
        if not isinstance(db, Session):
            raise ValueError("需要Session对象")
        
        try:
            result = func(*args, **kwargs)
            db.commit()
            return result
        except Exception as e:
            db.rollback()
            raise e
    return wrapper

@transactional
def create_user(db: Session, username: str, email: str):
    user = User(username=username, email=email)
    db.add(user)
    return user
```

## 6. 批量操作

### 6.1 批量插入

```python
# 方法1：bulk_insert_mappings
users_data = [
    {"username": "user1", "email": "user1@example.com"},
    {"username": "user2", "email": "user2@example.com"}
]
db.bulk_insert_mappings(User, users_data)
db.commit()

# 方法2：bulk_save_objects
users = [
    User(username="user1", email="user1@example.com"),
    User(username="user2", email="user2@example.com")
]
db.bulk_save_objects(users)
db.commit()
```

### 6.2 批量更新

```python
# 批量更新
db.query(User).filter(User.age < 18).update(
    {"status": "minor"},
    synchronize_session=False
)
db.commit()
```

## 7. 异步数据库操作

### 7.1 异步引擎

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

async_engine = create_async_engine(
    'postgresql+asyncpg://user:password@localhost/dbname',
    pool_size=10,
    max_overflow=20
)

AsyncSessionLocal = sessionmaker(
    async_engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_async_db():
    async with AsyncSessionLocal() as session:
        yield session
```

### 7.2 异步操作

```python
async def get_users_async(db: AsyncSession):
    result = await db.execute(select(User))
    users = result.scalars().all()
    return users

async def create_user_async(db: AsyncSession, username: str):
    user = User(username=username)
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user
```

## 8. 数据库迁移

### 8.1 Alembic 配置

```bash
# 初始化
alembic init alembic

# 创建迁移
alembic revision --autogenerate -m "create users table"

# 执行迁移
alembic upgrade head

# 回滚
alembic downgrade -1
```

### 8.2 迁移脚本

```python
# alembic/versions/xxx_create_users.py
def upgrade():
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(50), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

def downgrade():
    op.drop_table('users')
```

## 9. 性能优化

### 9.1 查询优化

```python
# 使用joinedload避免N+1查询
from sqlalchemy.orm import joinedload

users = db.query(User).options(joinedload(User.profile)).all()

# 使用selectinload
from sqlalchemy.orm import selectinload

users = db.query(User).options(selectinload(User.orders)).all()

# 只加载需要的字段
users = db.query(User.id, User.username).all()
```

### 9.2 连接池优化

```python
# 根据负载调整连接池
engine = create_engine(
    url,
    pool_size=20,        # 增加连接池大小
    max_overflow=40,     # 增加溢出连接
    pool_pre_ping=True,   # 连接健康检查
    pool_recycle=1800     # 30分钟回收连接
)
```

## 10. 最佳实践

### 10.1 连接管理

- 使用连接池管理连接
- 及时关闭连接
- 设置合理的连接池大小
- 启用连接健康检查

### 10.2 事务管理

- 保持事务简短
- 及时提交或回滚
- 使用保存点处理复杂操作
- 避免长时间持有事务

### 10.3 错误处理

```python
def safe_db_operation(db: Session, operation):
    try:
        result = operation(db)
        db.commit()
        return result
    except Exception as e:
        db.rollback()
        logger.error(f"数据库操作失败: {e}")
        raise
```

## 11. 总结

数据库连接池和事务管理要点：
- **连接池**：复用连接，提高性能
- **会话管理**：正确管理会话生命周期
- **事务**：确保数据一致性
- **批量操作**：提高批量处理效率
- **异步操作**：支持异步数据库操作
- **迁移**：使用Alembic管理数据库变更
- **性能优化**：查询优化和连接池调优

良好的连接池和事务管理是数据库应用稳定运行的基础。

