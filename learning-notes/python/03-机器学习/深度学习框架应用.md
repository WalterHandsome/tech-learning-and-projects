# 深度学习框架应用

> TensorFlow 和 PyTorch 深度学习框架实践

## 1. TensorFlow 基础

### 1.1 安装和导入

```bash
pip install tensorflow
```

```python
import tensorflow as tf
print(tf.__version__)
```

### 1.2 张量操作

```python
# 创建张量
x = tf.constant([[1, 2, 3], [4, 5, 6]])
y = tf.constant([[7, 8, 9], [10, 11, 12]])

# 张量运算
z = tf.add(x, y)
z = tf.matmul(x, tf.transpose(y))

# 张量形状
print(x.shape)  # (2, 3)
print(tf.rank(x))  # 2
```

### 1.3 构建神经网络

```python
from tensorflow.keras import layers, models

# 创建模型
model = models.Sequential([
    layers.Dense(128, activation='relu', input_shape=(784,)),
    layers.Dropout(0.2),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

# 编译模型
model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

# 训练模型
model.fit(X_train, y_train, epochs=10, validation_data=(X_val, y_val))
```

## 2. PyTorch 基础

### 2.1 安装和导入

```bash
pip install torch torchvision
```

```python
import torch
import torch.nn as nn
import torch.optim as optim
```

### 2.2 张量操作

```python
# 创建张量
x = torch.tensor([[1, 2, 3], [4, 5, 6]])
y = torch.tensor([[7, 8, 9], [10, 11, 12]])

# 张量运算
z = x + y
z = torch.matmul(x, y.T)

# GPU支持
if torch.cuda.is_available():
    x = x.cuda()
```

### 2.3 构建神经网络

```python
class NeuralNetwork(nn.Module):
    def __init__(self):
        super(NeuralNetwork, self).__init__()
        self.fc1 = nn.Linear(784, 128)
        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(0.2)
        self.fc2 = nn.Linear(128, 64)
        self.fc3 = nn.Linear(64, 10)
    
    def forward(self, x):
        x = self.fc1(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc2(x)
        x = self.relu(x)
        x = self.fc3(x)
        return x

# 创建模型
model = NeuralNetwork()
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# 训练
for epoch in range(10):
    for batch_x, batch_y in dataloader:
        optimizer.zero_grad()
        outputs = model(batch_x)
        loss = criterion(outputs, batch_y)
        loss.backward()
        optimizer.step()
```

## 3. 卷积神经网络（CNN）

### 3.1 TensorFlow CNN

```python
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(10, activation='softmax')
])
```

### 3.2 PyTorch CNN

```python
class CNN(nn.Module):
    def __init__(self):
        super(CNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, 3)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(32, 64, 3)
        self.fc1 = nn.Linear(64 * 5 * 5, 128)
        self.fc2 = nn.Linear(128, 10)
    
    def forward(self, x):
        x = self.pool(torch.relu(self.conv1(x)))
        x = self.pool(torch.relu(self.conv2(x)))
        x = x.view(-1, 64 * 5 * 5)
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x
```

## 4. 循环神经网络（RNN/LSTM）

### 4.1 LSTM 实现

```python
# TensorFlow
model = models.Sequential([
    layers.LSTM(50, return_sequences=True, input_shape=(timesteps, features)),
    layers.LSTM(50),
    layers.Dense(1)
])

# PyTorch
class LSTMNet(nn.Module):
    def __init__(self, input_size, hidden_size, num_layers):
        super(LSTMNet, self).__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, 1)
    
    def forward(self, x):
        out, _ = self.lstm(x)
        out = self.fc(out[:, -1, :])
        return out
```

## 5. 迁移学习

### 5.1 使用预训练模型

```python
# TensorFlow
from tensorflow.keras.applications import VGG16

base_model = VGG16(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.trainable = False

model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(128, activation='relu'),
    layers.Dense(num_classes, activation='softmax')
])

# PyTorch
import torchvision.models as models

model = models.resnet18(pretrained=True)
model.fc = nn.Linear(model.fc.in_features, num_classes)
```

## 6. 模型保存和加载

### 6.1 TensorFlow

```python
# 保存
model.save('my_model.h5')

# 加载
model = tf.keras.models.load_model('my_model.h5')
```

### 6.2 PyTorch

```python
# 保存
torch.save(model.state_dict(), 'model.pth')

# 加载
model = NeuralNetwork()
model.load_state_dict(torch.load('model.pth'))
```

## 7. 总结

深度学习框架要点：
- **TensorFlow**：Keras API、Sequential模型、函数式API
- **PyTorch**：动态图、nn.Module、自动求导
- **CNN**：图像分类、特征提取
- **RNN/LSTM**：序列数据、时间序列
- **迁移学习**：预训练模型、微调
- **模型管理**：保存、加载、部署

选择合适的框架和模型架构是深度学习成功的关键。

