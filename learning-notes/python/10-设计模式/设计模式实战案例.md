# 设计模式实战案例

> 设计模式在实际项目中的应用场景和实现

## 1. 观察者模式 - 事件系统

### 1.1 实现事件发布订阅

```python
class Event:
    def __init__(self, name, data=None):
        self.name = name
        self.data = data

class EventEmitter:
    def __init__(self):
        self._listeners = {}
    
    def on(self, event_name, callback):
        if event_name not in self._listeners:
            self._listeners[event_name] = []
        self._listeners[event_name].append(callback)
    
    def emit(self, event_name, data=None):
        if event_name in self._listeners:
            event = Event(event_name, data)
            for callback in self._listeners[event_name]:
                callback(event)
    
    def off(self, event_name, callback):
        if event_name in self._listeners:
            self._listeners[event_name].remove(callback)

# 使用
emitter = EventEmitter()
emitter.on('user_created', lambda e: print(f"用户创建: {e.data}"))
emitter.emit('user_created', {'id': 1, 'name': 'Alice'})
```

## 2. 策略模式 - 支付系统

### 2.1 多种支付方式

```python
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> bool:
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number: str):
        self.card_number = card_number
    
    def pay(self, amount: float) -> bool:
        print(f"使用信用卡 {self.card_number} 支付 {amount} 元")
        return True

class AlipayPayment(PaymentStrategy):
    def pay(self, amount: float) -> bool:
        print(f"使用支付宝支付 {amount} 元")
        return True

class WeChatPayment(PaymentStrategy):
    def pay(self, amount: float) -> bool:
        print(f"使用微信支付 {amount} 元")
        return True

class PaymentContext:
    def __init__(self, strategy: PaymentStrategy):
        self.strategy = strategy
    
    def execute_payment(self, amount: float) -> bool:
        return self.strategy.pay(amount)

# 使用
payment = PaymentContext(AlipayPayment())
payment.execute_payment(100.0)
```

## 3. 装饰器模式 - 功能增强

### 3.1 日志和缓存装饰器

```python
import functools
import time
from typing import Callable

def log_execution(func: Callable) -> Callable:
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"执行函数: {func.__name__}")
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"函数 {func.__name__} 执行时间: {end - start:.2f}秒")
        return result
    return wrapper

def cache_result(func: Callable) -> Callable:
    cache = {}
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key in cache:
            return cache[key]
        result = func(*args, **kwargs)
        cache[key] = result
        return result
    return wrapper

@log_execution
@cache_result
def expensive_function(n: int) -> int:
    time.sleep(1)
    return n * 2
```

## 4. 适配器模式 - API适配

### 4.1 统一不同API接口

```python
class OldAPI:
    def get_user_data(self, user_id: int):
        return {"id": user_id, "name": "User"}

class NewAPI:
    def fetch_user(self, identifier: int):
        return {"user_id": identifier, "username": "User"}

class APIAdapter:
    def __init__(self, api):
        self.api = api
    
    def get_user(self, user_id: int):
        if isinstance(self.api, OldAPI):
            data = self.api.get_user_data(user_id)
            return {"user_id": data["id"], "username": data["name"]}
        elif isinstance(self.api, NewAPI):
            return self.api.fetch_user(user_id)

# 使用
old_api = OldAPI()
adapter = APIAdapter(old_api)
user = adapter.get_user(1)
```

## 5. 责任链模式 - 请求处理

### 5.1 中间件链

```python
from abc import ABC, abstractmethod

class Handler(ABC):
    def __init__(self):
        self._next = None
    
    def set_next(self, handler):
        self._next = handler
        return handler
    
    @abstractmethod
    def handle(self, request):
        if self._next:
            return self._next.handle(request)
        return None

class AuthHandler(Handler):
    def handle(self, request):
        if not request.get('token'):
            return {"error": "未认证"}
        print("认证通过")
        return super().handle(request)

class ValidationHandler(Handler):
    def handle(self, request):
        if not request.get('data'):
            return {"error": "数据无效"}
        print("验证通过")
        return super().handle(request)

class BusinessHandler(Handler):
    def handle(self, request):
        print("处理业务逻辑")
        return {"success": True, "data": request['data']}

# 构建责任链
auth = AuthHandler()
validation = ValidationHandler()
business = BusinessHandler()

auth.set_next(validation).set_next(business)

# 使用
request = {"token": "abc123", "data": "test"}
result = auth.handle(request)
```

## 6. 模板方法模式 - 算法框架

### 6.1 数据处理流程

```python
from abc import ABC, abstractmethod

class DataProcessor(ABC):
    def process(self, data):
        """模板方法"""
        data = self.load(data)
        data = self.transform(data)
        data = self.validate(data)
        return self.save(data)
    
    @abstractmethod
    def load(self, data):
        pass
    
    @abstractmethod
    def transform(self, data):
        pass
    
    def validate(self, data):
        """钩子方法，可以被子类覆盖"""
        return data
    
    @abstractmethod
    def save(self, data):
        pass

class CSVProcessor(DataProcessor):
    def load(self, data):
        print("加载CSV文件")
        return data
    
    def transform(self, data):
        print("转换CSV数据")
        return data.upper()
    
    def save(self, data):
        print("保存CSV文件")
        return data

class JSONProcessor(DataProcessor):
    def load(self, data):
        print("加载JSON文件")
        return data
    
    def transform(self, data):
        print("转换JSON数据")
        return data.lower()
    
    def save(self, data):
        print("保存JSON文件")
        return data
```

## 7. 状态模式 - 状态机

### 7.1 订单状态管理

```python
from abc import ABC, abstractmethod

class OrderState(ABC):
    @abstractmethod
    def process(self, order):
        pass
    
    @abstractmethod
    def cancel(self, order):
        pass

class PendingState(OrderState):
    def process(self, order):
        print("订单处理中...")
        order.state = ProcessingState()
    
    def cancel(self, order):
        print("订单已取消")
        order.state = CancelledState()

class ProcessingState(OrderState):
    def process(self, order):
        print("订单处理完成")
        order.state = CompletedState()
    
    def cancel(self, order):
        print("订单处理中，无法取消")

class CompletedState(OrderState):
    def process(self, order):
        print("订单已完成")
    
    def cancel(self, order):
        print("订单已完成，无法取消")

class CancelledState(OrderState):
    def process(self, order):
        print("订单已取消，无法处理")
    
    def cancel(self, order):
        print("订单已取消")

class Order:
    def __init__(self):
        self.state = PendingState()
    
    def process(self):
        self.state.process(self)
    
    def cancel(self):
        self.state.cancel(self)
```

## 8. 命令模式 - 操作撤销

### 8.1 可撤销操作

```python
from abc import ABC, abstractmethod

class Command(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

class AddCommand(Command):
    def __init__(self, receiver, value):
        self.receiver = receiver
        self.value = value
    
    def execute(self):
        self.receiver.add(self.value)
    
    def undo(self):
        self.receiver.subtract(self.value)

class SubtractCommand(Command):
    def __init__(self, receiver, value):
        self.receiver = receiver
        self.value = value
    
    def execute(self):
        self.receiver.subtract(self.value)
    
    def undo(self):
        self.receiver.add(self.value)

class Calculator:
    def __init__(self):
        self.value = 0
    
    def add(self, n):
        self.value += n
    
    def subtract(self, n):
        self.value -= n

class Invoker:
    def __init__(self):
        self.history = []
    
    def execute(self, command):
        command.execute()
        self.history.append(command)
    
    def undo(self):
        if self.history:
            command = self.history.pop()
            command.undo()

# 使用
calc = Calculator()
invoker = Invoker()

invoker.execute(AddCommand(calc, 10))
invoker.execute(SubtractCommand(calc, 5))
print(calc.value)  # 5

invoker.undo()
print(calc.value)  # 10
```

## 9. 外观模式 - 简化接口

### 9.1 系统简化接口

```python
class CPU:
    def start(self):
        print("CPU启动")
    
    def shutdown(self):
        print("CPU关闭")

class Memory:
    def load(self):
        print("内存加载")
    
    def unload(self):
        print("内存卸载")

class HardDrive:
    def read(self):
        print("硬盘读取")
    
    def write(self):
        print("硬盘写入")

class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hard_drive = HardDrive()
    
    def start(self):
        self.cpu.start()
        self.memory.load()
        self.hard_drive.read()
        print("计算机启动完成")
    
    def shutdown(self):
        self.cpu.shutdown()
        self.memory.unload()
        self.hard_drive.write()
        print("计算机关闭完成")

# 使用
computer = ComputerFacade()
computer.start()
computer.shutdown()
```

## 10. 代理模式 - 延迟加载

### 10.1 虚拟代理

```python
class Image:
    def __init__(self, filename):
        self.filename = filename
        self._image = None
        self._load()
    
    def _load(self):
        print(f"加载图片: {self.filename}")
        # 模拟加载
        self._image = f"Image data from {self.filename}"
    
    def display(self):
        print(f"显示图片: {self._image}")

class ImageProxy:
    def __init__(self, filename):
        self.filename = filename
        self._image = None
    
    def display(self):
        if self._image is None:
            self._image = Image(self.filename)
        self._image.display()

# 使用
proxy = ImageProxy("large_image.jpg")
# 此时图片还未加载
proxy.display()  # 现在才加载
```

## 11. 总结

设计模式实战应用：
- **观察者模式**：事件系统、发布订阅
- **策略模式**：多种算法选择
- **装饰器模式**：功能增强
- **适配器模式**：接口适配
- **责任链模式**：请求处理链
- **模板方法**：算法框架
- **状态模式**：状态管理
- **命令模式**：操作撤销
- **外观模式**：简化接口
- **代理模式**：延迟加载、访问控制

这些模式在实际项目中经常使用，合理应用可以提高代码质量和可维护性。

