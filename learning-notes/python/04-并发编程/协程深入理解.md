# 协程深入理解

> Python 协程（Coroutine）的深入理解和高级应用

## 1. 协程基础

### 1.1 生成器协程

```python
def simple_coroutine():
    print("协程启动")
    x = yield
    print(f"收到值: {x}")
    y = yield x * 2
    print(f"收到值: {y}")

coro = simple_coroutine()
next(coro)  # 启动协程
coro.send(10)  # 发送值
coro.send(20)  # 发送值
```

### 1.2 async/await 协程

```python
import asyncio

async def fetch_data():
    print("开始获取数据")
    await asyncio.sleep(1)  # 模拟IO操作
    print("数据获取完成")
    return "data"

async def main():
    result = await fetch_data()
    print(result)

asyncio.run(main())
```

## 2. 协程调度

### 2.1 并发执行

```python
async def task(name, delay):
    print(f"任务 {name} 开始")
    await asyncio.sleep(delay)
    print(f"任务 {name} 完成")
    return f"结果 {name}"

async def main():
    # 并发执行多个任务
    results = await asyncio.gather(
        task("A", 1),
        task("B", 2),
        task("C", 3)
    )
    print(results)

asyncio.run(main())
```

### 2.2 任务管理

```python
async def main():
    # 创建任务
    task1 = asyncio.create_task(task("A", 1))
    task2 = asyncio.create_task(task("B", 2))
    
    # 等待任务完成
    result1 = await task1
    result2 = await task2
    
    # 取消任务
    task3 = asyncio.create_task(task("C", 5))
    await asyncio.sleep(0.1)
    task3.cancel()
    try:
        await task3
    except asyncio.CancelledError:
        print("任务已取消")
```

## 3. 协程通信

### 3.1 异步队列

```python
import asyncio

async def producer(queue):
    for i in range(5):
        await queue.put(i)
        print(f"生产: {i}")
        await asyncio.sleep(0.5)
    await queue.put(None)  # 结束信号

async def consumer(queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"消费: {item}")
        await asyncio.sleep(0.3)
        queue.task_done()

async def main():
    queue = asyncio.Queue()
    await asyncio.gather(
        producer(queue),
        consumer(queue)
    )

asyncio.run(main())
```

### 3.2 异步锁

```python
async def worker(lock, name):
    async with lock:
        print(f"{name} 获得锁")
        await asyncio.sleep(1)
        print(f"{name} 释放锁")

async def main():
    lock = asyncio.Lock()
    await asyncio.gather(
        worker(lock, "A"),
        worker(lock, "B"),
        worker(lock, "C")
    )

asyncio.run(main())
```

## 4. 协程与线程

### 4.1 在线程中运行协程

```python
import asyncio
import threading

def run_in_thread():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(async_task())

thread = threading.Thread(target=run_in_thread)
thread.start()
```

### 4.2 在协程中运行同步代码

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor(max_workers=3)

async def async_with_sync():
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(executor, blocking_function)
    return result
```

## 5. 协程模式

### 5.1 生产者-消费者模式

```python
async def producer(queue, count):
    for i in range(count):
        await queue.put(i)
        await asyncio.sleep(0.1)

async def consumer(queue, name):
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"{name} 处理: {item}")
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=10)
    producers = [asyncio.create_task(producer(queue, 5)) for _ in range(2)]
    consumers = [asyncio.create_task(consumer(queue, f"C{i}")) for i in range(3)]
    
    await asyncio.gather(*producers)
    await queue.join()
    for _ in consumers:
        await queue.put(None)
    await asyncio.gather(*consumers)

asyncio.run(main())
```

## 6. 总结

协程深入理解要点：
- **协程基础**：生成器协程、async/await
- **协程调度**：并发执行、任务管理
- **协程通信**：异步队列、异步锁
- **协程与线程**：混合使用、执行器
- **协程模式**：生产者-消费者、并发模式

协程是Python异步编程的核心。

