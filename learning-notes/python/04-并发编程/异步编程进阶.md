# 异步编程进阶

> 深入理解 asyncio 和异步编程的高级特性

## 1. 异步上下文管理器

### 1.1 实现异步上下文管理器

```python
import asyncio

class AsyncResource:
    async def __aenter__(self):
        print("获取资源")
        await asyncio.sleep(0.1)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("释放资源")
        await asyncio.sleep(0.1)
        return False

async def use_resource():
    async with AsyncResource() as resource:
        print("使用资源")
        await asyncio.sleep(1)

asyncio.run(use_resource())
```

### 1.2 使用 contextlib

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_resource():
    print("获取资源")
    await asyncio.sleep(0.1)
    try:
        yield "resource"
    finally:
        print("释放资源")
        await asyncio.sleep(0.1)

async def main():
    async with async_resource() as res:
        print(f"使用 {res}")

asyncio.run(main())
```

## 2. 异步迭代器

### 2.1 实现异步迭代器

```python
class AsyncRange:
    def __init__(self, start, stop):
        self.start = start
        self.stop = stop
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.start >= self.stop:
            raise StopAsyncIteration
        await asyncio.sleep(0.1)  # 模拟异步操作
        value = self.start
        self.start += 1
        return value

async def main():
    async for i in AsyncRange(0, 5):
        print(i)

asyncio.run(main())
```

### 2.2 异步生成器

```python
async def async_generator(n):
    for i in range(n):
        await asyncio.sleep(0.1)
        yield i * 2

async def main():
    async for value in async_generator(5):
        print(value)

asyncio.run(main())
```

## 3. 异步队列

### 3.1 异步队列使用

```python
async def producer(queue, n):
    for i in range(n):
        await asyncio.sleep(0.5)
        await queue.put(i)
        print(f"生产: {i}")
    await queue.put(None)  # 结束信号

async def consumer(queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        await asyncio.sleep(0.2)
        print(f"消费: {item}")
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=5)
    
    await asyncio.gather(
        producer(queue, 10),
        consumer(queue)
    )

asyncio.run(main())
```

### 3.2 优先级队列

```python
import heapq

class AsyncPriorityQueue:
    def __init__(self):
        self._queue = []
        self._counter = 0
    
    async def put(self, item, priority):
        heapq.heappush(self._queue, (priority, self._counter, item))
        self._counter += 1
    
    async def get(self):
        _, _, item = heapq.heappop(self._queue)
        return item
    
    def empty(self):
        return len(self._queue) == 0

async def main():
    pq = AsyncPriorityQueue()
    await pq.put("低优先级", 3)
    await pq.put("高优先级", 1)
    await pq.put("中优先级", 2)
    
    while not pq.empty():
        item = await pq.get()
        print(item)

asyncio.run(main())
```

## 4. 信号量和锁

### 4.1 异步信号量

```python
async def worker(semaphore, name):
    async with semaphore:
        print(f"{name} 开始工作")
        await asyncio.sleep(2)
        print(f"{name} 完成工作")

async def main():
    semaphore = asyncio.Semaphore(3)  # 最多3个并发
    
    tasks = [
        worker(semaphore, f"Worker-{i}")
        for i in range(10)
    ]
    
    await asyncio.gather(*tasks)

asyncio.run(main())
```

### 4.2 异步锁

```python
async def critical_section(lock, name):
    async with lock:
        print(f"{name} 进入临界区")
        await asyncio.sleep(1)
        print(f"{name} 离开临界区")

async def main():
    lock = asyncio.Lock()
    
    tasks = [
        critical_section(lock, f"Task-{i}")
        for i in range(5)
    ]
    
    await asyncio.gather(*tasks)

asyncio.run(main())
```

## 5. 异步事件和条件

### 5.1 异步事件

```python
async def waiter(event, name):
    print(f"{name} 等待事件")
    await event.wait()
    print(f"{name} 事件已触发")

async def setter(event):
    await asyncio.sleep(2)
    print("触发事件")
    event.set()

async def main():
    event = asyncio.Event()
    
    await asyncio.gather(
        waiter(event, "Waiter-1"),
        waiter(event, "Waiter-2"),
        setter(event)
    )

asyncio.run(main())
```

### 5.2 异步条件

```python
async def consumer(condition, items):
    async with condition:
        while len(items) == 0:
            await condition.wait()
        item = items.pop(0)
        print(f"消费: {item}")

async def producer(condition, items):
    for i in range(5):
        await asyncio.sleep(0.5)
        async with condition:
            items.append(i)
            print(f"生产: {i}")
            condition.notify()

async def main():
    condition = asyncio.Condition()
    items = []
    
    await asyncio.gather(
        producer(condition, items),
        consumer(condition, items),
        consumer(condition, items)
    )

asyncio.run(main())
```

## 6. 异步超时和取消

### 6.1 超时控制

```python
async def slow_task():
    await asyncio.sleep(5)
    return "完成"

async def main():
    try:
        result = await asyncio.wait_for(slow_task(), timeout=2.0)
        print(result)
    except asyncio.TimeoutError:
        print("任务超时")

asyncio.run(main())
```

### 6.2 任务取消

```python
async def cancellable_task():
    try:
        while True:
            print("运行中...")
            await asyncio.sleep(0.5)
    except asyncio.CancelledError:
        print("任务被取消")
        raise

async def main():
    task = asyncio.create_task(cancellable_task())
    await asyncio.sleep(2)
    task.cancel()
    
    try:
        await task
    except asyncio.CancelledError:
        print("任务已取消")

asyncio.run(main())
```

## 7. 异步批处理

### 7.1 批量处理

```python
async def process_batch(items):
    """批量处理"""
    results = []
    for item in items:
        await asyncio.sleep(0.1)
        results.append(item * 2)
    return results

async def batch_processor(data, batch_size=5):
    """分批处理数据"""
    batches = [data[i:i+batch_size] for i in range(0, len(data), batch_size)]
    
    tasks = [process_batch(batch) for batch in batches]
    results = await asyncio.gather(*tasks)
    
    return [item for sublist in results for item in sublist]

async def main():
    data = list(range(20))
    results = await batch_processor(data, batch_size=5)
    print(results)

asyncio.run(main())
```

## 8. 异步重试机制

### 8.1 重试装饰器

```python
import functools

def async_retry(max_attempts=3, delay=1):
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"尝试 {attempt + 1} 失败，{delay}秒后重试...")
                    await asyncio.sleep(delay)
        return wrapper
    return decorator

@async_retry(max_attempts=3, delay=1)
async def unreliable_task():
    import random
    if random.random() < 0.7:
        raise Exception("随机失败")
    return "成功"

asyncio.run(unreliable_task())
```

## 9. 性能优化

### 9.1 并发控制

```python
async def fetch_with_semaphore(semaphore, session, url):
    async with semaphore:
        async with session.get(url) as response:
            return await response.text()

async def main():
    semaphore = asyncio.Semaphore(10)  # 限制并发数
    async with aiohttp.ClientSession() as session:
        urls = ["https://example.com"] * 100
        tasks = [
            fetch_with_semaphore(semaphore, session, url)
            for url in urls
        ]
        results = await asyncio.gather(*tasks)
```

## 10. 总结

异步编程进阶要点：
- **异步上下文管理器**：资源管理
- **异步迭代器**：异步数据流
- **异步队列**：任务协调
- **信号量和锁**：并发控制
- **超时和取消**：任务管理
- **批处理**：提高效率
- **重试机制**：提高可靠性

